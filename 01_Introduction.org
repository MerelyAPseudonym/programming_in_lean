#+Title: Programming in Lean
#+Author: [[http://www.andrew.cmu.edu/user/avigad][Jeremy Avigad]], [[http://leodemoura.github.io][Leonardo de Moura]], [[http://jroesch.github.io/][Jared Roesch]]

* Introduction
:PROPERTIES:
  :CUSTOM_ID: Introduction
:END:

/Warning./ This book is still under construction. It aims to serve as
both an introduction and a reference manual for programming in the
Lean theorem prover.

We are making this material public now because currently it is the
only existing documentation for many of the specifics of the Lean
programming language and its API, and we are hoping that the
information will be useful to brave souls experimenting with it at
this early stage. Most of the chapters are currently only stubs, but
comments and feedback on the material that is available will be
helpful.

** Lean as a Programming Language

This book can be viewed as a companion to [[https://leanprover.github.io/theorem_proving_in_lean/][Theorem Proving in Lean]],
which presents Lean as a system for building mathematical libraries
and stating and proving mathematical theorems.  From that perspective,
the point of Lean is to implement a formal axiomatic framework in
which one can define mathematical objects and reason about them.

As noted in that book, however, expressions in Lean have a
computational interpretation, which is to say, they can be
/evaluated/. As long as it is defined in the computational fragment of
Lean's foundational language, any closed term of type =nat= -- that
is, any term of type =nat= without free variables -- evaluates to a
numeral. Similarly, any closed term of type =list nat= evaluates to a
list of numerals, and any closed term of type =bool= evaluates
either to the boolean value =tt=, for "true," or =ff=, for "false."

This provides another perspective on Lean: instead of thinking of it
as a theorem prover whose language just happens to have a
computational interpretation, think of it as a programming language
that just happens to come equipped with a rich specification language
and an interactive environment for proving that programs meet their
specifications. The specification language and proof system are quite
powerful, rich enough, in fact, to include all conventional
mathematics.

We will see that Lean's underlying logical framework, the Calculus of
Inductive Constructions, constitutes a surprisingly good programming
language. It is expressive enough to define all sorts of data
structures, and it supports powerful abstractions. Programs written in
the language can be evaluated efficiently by Lean's virtual-machine
interpreter or translated automatically to C++ and compiled.

Viewed from a computational perspective, the Calculus of Inductive
Constructions is an instance of a purely functional programming
language. This means that a program in Lean is simply an expression
whose value is determined compositionally from the values of the other
expressions it refers to, independent of any sort of ambient state of
computation. There is no notion of storing a result in memory or
changing the value of a global variable; computation is just
evaluation of expressions. This paradigm makes it easier to reason
about programs and verify their correctness. At the same time, we will
see that Lean incorporates concepts and abstractions that make it
feasible to use this paradigm in practice.

The underlying foundational framework imposes one restriction that is
alien to most programming languages, namely, that every program is
terminating. So, for example, every "while" loop has to be explicitly
bounded, though, of course, we can consider the result of iterating an
arbitrary computation =n= times for any given natural number =n=. We
will see that Lean provides flexible mechanisms for structural and
well-founded recursion, allowing us to define functions in natural
ways. At the same, the system provides complementary mechanisms for
proving claims, using inductive principles that capture the structure
of the function definitions.

** Examples

For example...

[Define something like factorial. Evaluate (use both =eval= and =vm_eval=).]

[Define operations on lists.]

[Prove things, like ~length (reverse l) = length l~ or ~reverse
(reverse l) = l~.]

** Input and Output

People often want to write programs that interact with the outside
world, querying users for input and presenting them with output during
the course of a computation. Lean's foundational framework has no
model of "the real world," but Lean declares =get_str= and =put_str=
commands to get an input string from the user and write an input
string to output, respectively. Within the foundational system, these
are treated as black box operations. But when programs are evaluated
by Lean's virtual machine or when they are translated to C++, they
have the expected behavior. Here, for example, is a program that
prints "hello world":
#+BEGIN_SRC lean
import system.io

def hello_world : io unit :=
put_str "hello world\n"

vm_eval hello_world
#+END_SRC

#+RESULTS:
: hello world
: 

The next example prints the first 100 squares:
#+BEGIN_SRC lean
import system.io
open nat

def print_squares : ℕ → io unit
| 0        := return ()
| (succ n) := print_squares n >>
              put_str (nat.to_string n ++ "^2 = " ++ 
                       nat.to_string (n * n) ++ "\n")

vm_eval print_squares 100
#+END_SRC

#+RESULTS:
#+begin_example
0^2 = 0
1^2 = 1
2^2 = 4
3^2 = 9
4^2 = 16
5^2 = 25
6^2 = 36
7^2 = 49
8^2 = 64
9^2 = 81
10^2 = 100
11^2 = 121
12^2 = 144
13^2 = 169
14^2 = 196
15^2 = 225
16^2 = 256
17^2 = 289
18^2 = 324
19^2 = 361
20^2 = 400
21^2 = 441
22^2 = 484
23^2 = 529
24^2 = 576
25^2 = 625
26^2 = 676
27^2 = 729
28^2 = 784
29^2 = 841
30^2 = 900
31^2 = 961
32^2 = 1024
33^2 = 1089
34^2 = 1156
35^2 = 1225
36^2 = 1296
37^2 = 1369
38^2 = 1444
39^2 = 1521
40^2 = 1600
41^2 = 1681
42^2 = 1764
43^2 = 1849
44^2 = 1936
45^2 = 2025
46^2 = 2116
47^2 = 2209
48^2 = 2304
49^2 = 2401
50^2 = 2500
51^2 = 2601
52^2 = 2704
53^2 = 2809
54^2 = 2916
55^2 = 3025
56^2 = 3136
57^2 = 3249
58^2 = 3364
59^2 = 3481
60^2 = 3600
61^2 = 3721
62^2 = 3844
63^2 = 3969
64^2 = 4096
65^2 = 4225
66^2 = 4356
67^2 = 4489
68^2 = 4624
69^2 = 4761
70^2 = 4900
71^2 = 5041
72^2 = 5184
73^2 = 5329
74^2 = 5476
75^2 = 5625
76^2 = 5776
77^2 = 5929
78^2 = 6084
79^2 = 6241
80^2 = 6400
81^2 = 6561
82^2 = 6724
83^2 = 6889
84^2 = 7056
85^2 = 7225
86^2 = 7396
87^2 = 7569
88^2 = 7744
89^2 = 7921
90^2 = 8100
91^2 = 8281
92^2 = 8464
93^2 = 8649
94^2 = 8836
95^2 = 9025
96^2 = 9216
97^2 = 9409
98^2 = 9604
99^2 = 9801

#+end_example

We will explain the data type =io unit= in Chapter [[file:07_Monads::#Monads][Monads]]. Although
this program has a real world side effect of sending output to the
screen when run, that effect is invisible to the formal
foundation. From the latter's perspective, the type constructor =io=
and the functions =put_str= and =get_str= are entirely opaque, objects
about which that the axiomatic system has nothing to say. The =print
axioms= command shows that the expression =hello world= depends on the
constants =io= and =put_str=, which have been forcibly added to the
axiomatic system.
#+BEGIN_SRC lean
import system.io

def hello_world : io unit :=
put_str "hello world\n"

-- BEGIN
print axioms hello_world
-- END
#+END_SRC

#+RESULTS:
: io
: put_str

In this way, we can prove properties of programs involving =io= that
do not depend in any way on the particular results of the input and
output.

# At some point, we can mention the possibility of extending Lean with
# other axiomatically declared elements.

** Metaprogramming in Lean
:PROPERTIES:
  :CUSTOM_ID: Metaprogramming_in_Lean
:END:

Lean also allows /metaprograms/, which are Lean programs that involve
objects and constructs that are not part of the axiomatic
foundation. In particular:
- Metaprograms can use arbitrary recursive calls, with no concern for
  termination.
- Metaprograms can access /metaconstants/, that is, primitive
  functions and objects that are implemented internally in Lean and
  are not meant to be trusted by the foundational framework.
Such definitions can be introduced using the keywords =meta def=
instead of =def= and are marked for special treatment. In particular,
because they are not part of the axiomatic foundation, they cannot
appear as part of ordinary Lean definitions and theorems.

For example, the following definition computes McCarthy's 91 function,
without verifying that the computation terminates on all inputs
(though, in fact, it does):
# TODO: change definition of m91 when we can write the recursion 
#       directly
#+BEGIN_SRC lean
meta def m91 : ℕ → ℕ
| n := if n > 100 then n - 10 else m91 (m91 (n + 11))

vm_eval m91 10
vm_eval m91 100
vm_eval m91 1000
#+END_SRC

#+RESULTS:
: 91
: 91
: 990

We can print out the first 120 values of =m91=:
#+BEGIN_SRC lean
import system.io
open nat

meta def m91 : ℕ → ℕ
| n := if n > 100 then n - 10 else m91 (m91 (n + 11))

-- BEGIN
meta def print_m91 : ℕ → io unit
| 0        := return ()
| (succ n) := print_m91 n >>
              put_str ("m91 " ++ nat.to_string n ++ " = " ++ 
                       nat.to_string (m91 n) ++ "\n")

vm_eval print_m91 120
-- END
#+END_SRC

#+RESULTS:
#+begin_example
m91 0 = 91
m91 1 = 91
m91 2 = 91
m91 3 = 91
m91 4 = 91
m91 5 = 91
m91 6 = 91
m91 7 = 91
m91 8 = 91
m91 9 = 91
m91 10 = 91
m91 11 = 91
m91 12 = 91
m91 13 = 91
m91 14 = 91
m91 15 = 91
m91 16 = 91
m91 17 = 91
m91 18 = 91
m91 19 = 91
m91 20 = 91
m91 21 = 91
m91 22 = 91
m91 23 = 91
m91 24 = 91
m91 25 = 91
m91 26 = 91
m91 27 = 91
m91 28 = 91
m91 29 = 91
m91 30 = 91
m91 31 = 91
m91 32 = 91
m91 33 = 91
m91 34 = 91
m91 35 = 91
m91 36 = 91
m91 37 = 91
m91 38 = 91
m91 39 = 91
m91 40 = 91
m91 41 = 91
m91 42 = 91
m91 43 = 91
m91 44 = 91
m91 45 = 91
m91 46 = 91
m91 47 = 91
m91 48 = 91
m91 49 = 91
m91 50 = 91
m91 51 = 91
m91 52 = 91
m91 53 = 91
m91 54 = 91
m91 55 = 91
m91 56 = 91
m91 57 = 91
m91 58 = 91
m91 59 = 91
m91 60 = 91
m91 61 = 91
m91 62 = 91
m91 63 = 91
m91 64 = 91
m91 65 = 91
m91 66 = 91
m91 67 = 91
m91 68 = 91
m91 69 = 91
m91 70 = 91
m91 71 = 91
m91 72 = 91
m91 73 = 91
m91 74 = 91
m91 75 = 91
m91 76 = 91
m91 77 = 91
m91 78 = 91
m91 79 = 91
m91 80 = 91
m91 81 = 91
m91 82 = 91
m91 83 = 91
m91 84 = 91
m91 85 = 91
m91 86 = 91
m91 87 = 91
m91 88 = 91
m91 89 = 91
m91 90 = 91
m91 91 = 91
m91 92 = 91
m91 93 = 91
m91 94 = 91
m91 95 = 91
m91 96 = 91
m91 97 = 91
m91 98 = 91
m91 99 = 91
m91 100 = 91
m91 101 = 91
m91 102 = 92
m91 103 = 93
m91 104 = 94
m91 105 = 95
m91 106 = 96
m91 107 = 97
m91 108 = 98
m91 109 = 99
m91 110 = 100
m91 111 = 101
m91 112 = 102
m91 113 = 103
m91 114 = 104
m91 115 = 105
m91 116 = 106
m91 117 = 107
m91 118 = 108
m91 119 = 109

#+end_example

Of course, such uses of recursion are dangerous.
# TODO: replace with meta def foo : nat := foo + 1
#+BEGIN_SRC lean
meta def foo : ℕ → ℕ
| n := foo n + 1

eval foo
-- vm_eval foo 0
#+END_SRC

#+RESULTS:
: λ (a : ℕ), nat.succ ([foo] a)

Evaluating =foo= using the kernel evaluator shows that the
implementation is a bit of a hack; the term in the definition includes
a macro which names =foo= itself. The virtual machine that evaluates
foo goes further, and carries out the recursive call, repeating this
until the process runs out of memory. It is a good thing that Lean
will not allow =foo= to appear in a =theorem= or in an ordinary
=definition=; if we could prove ~foo = foo + 1~ then, substracting
=foo= from both sides, we could prove ~0 = 1~, and hence a
contradiction.

Although metaprograms can be used in various ways, its primary purpose
is to provide a means of extending the functionality of Lean, within
Lean itself. For example, we can use metaprograms to write new
procedures, known as /tactics/, which help us construct proofs. This
next example assumes you are familiar with the notion of a tactic, as
described in /Theorem Proving in Lean/.

The following code implements a tactic that, given any goal,
repeatedly finds a hypothesis =H= of the form =A ∧ B=, and
replaces it by hypotheses (with fresh names) for =A= and =B=.
#+BEGIN_SRC lean
open tactic monad expr

-- TODO: put this in expr
meta def head_symbol : expr → name
| (const n a)      := n
| (app e a)        := match (get_app_fn e) with
                      | (const n l) := n
                      | a           := `none
                      end
| (pi a₁ a₂ a₃ a₄) := `pi
| a                := `none

-- TODO: add this to tactic?
-- assuming (P : T), create a fresh name H, and add assert H : T
meta def assert_fact (P : expr) : tactic unit :=
do n ← mk_fresh_name,
   t ← infer_type P,
   assertv n t P

-- BEGIN
meta def destruct_conjunctions : tactic unit :=
repeat
  (do l ← local_context,
      first $ l^.for (λ h,
        do ht ← infer_type h >>= whnf,
           if head_symbol ht = ``and then do
              mk_mapp ``and.left [none, none, some h] >>= assert_fact,
              mk_mapp ``and.right [none, none, some h] >>= assert_fact,
              clear h
           else failed))
-- END
#+END_SRC

#+RESULTS:

We will explain the details in Chapter [[file:08_Writing_Tactics.org::#Writing_Tactics][Writing Tactics]], but, roughly
speaking, the code repeats the following action until there is nothing
left to do: get the list of hypotheses in the local context, find a
hypothesis =H= whose type is a conjunction, add new hypotheses
justified by =and.left H= and =and.right H= to the local context, and
then delete =H=. We can then use =destruct_conjunctions= like any
other Lean tactic.
#+BEGIN_SRC lean
open tactic monad expr

-- TODO: put this in expr
meta def head_symbol : expr → name
| (const n a)      := n
| (app e a)        := match (get_app_fn e) with
                      | (const n l) := n
                      | a           := `none
                      end
| (pi a₁ a₂ a₃ a₄) := `pi
| a                := `none

-- TODO: add this to tactic?
-- assuming (P : T), create a fresh name H, and add H : P
meta def assert_fact (P : expr) : tactic unit :=
do n ← mk_fresh_name,
   t ← infer_type P,
   assertv n t P

meta def destruct_conjunctions : tactic unit :=
repeat
  (do l ← local_context,
      first $ l^.for (λ h,
        do ht ← infer_type h >>= whnf,
           if head_symbol ht = ``and then do
              mk_mapp ``and.left [none, none, some h] >>= assert_fact,
              mk_mapp ``and.right [none, none, some h] >>= assert_fact,
              clear h
           else failed))

-- BEGIN
example (a b c : Prop) (H : (a ∧ b) ∧ (c ∧ a)) : c :=
begin destruct_conjunctions >> assumption end
-- END
#+END_SRC

#+RESULTS:

Note that the reason we can use such code to prove theorems without
compromising the integrity of the formal system is that Lean's kernel
always certifies the result. From a foundational point of view, we
don't have to worry about the integrity of the code, only the
integrity of the resulting proofs.

** Overview of the contents

To summarize, we can use Lean in any of the following ways:
- as a programming language
- as a system for verifying properties of programs
- as a system for writing metaprograms, that is, programs that extend
  the functionality of Lean itself

Chapters [[file:02_Programming_Basics.org::#Programming_Basics][2]] to [[file:07_Monads.org::#Monads][7]] explain how to use Lean as a programming language. It
will be helpful if you have some familiarity with the syntax and
meaning of dependent type theory, for example, as presented in
/Theorem Proving in Lean/ (henceforth /TPL/). But, if not, it is
likely that you will be able to pick up the details as we
proceed. Similarly, if you are familiar with functional programming,
you will be able to move through the material more quickly, but we
will try to keep the presentation below self contained.

[[file:04_Verifying_Properties_of_Programs.org::#Verifying_Properties_of_Programs][Chapter 4]] in particular deals with the task of proving things about
programs. Once again, it will be helpful if you are familiar with the
use of Lean as an interactive theorem prover as described in /TPL/,
but if not you are encouraged to forge ahead and refer back to /TPL/
as necessary.

Finally, [[file:08_Writing_Tactics.org::#Writing_Tactics][Chapter 8]] and [[file:09_Writing_Automation.org::#Writing_Automation][Chapter 9]] deal with metaprogramming aspects of
Lean, and, in particular, writing tactics and automation.
